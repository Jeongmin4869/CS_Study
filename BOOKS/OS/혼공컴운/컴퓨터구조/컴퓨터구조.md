# Chapter 1 컴퓨터 구조 시작하기

## 1-2 컴퓨터 구조의 큰 그림

컴퓨터 구조  
컴퓨터가 이해하는 정보  
컴퓨터의 네가지 핵심부품

---
### <컴퓨터가 이해하는 정보>

컴퓨터는 0과 1로 표현된 정보만을 이해한다.  
0과 1로 표현되는 정보에는 크게 두 가지가 있는데 바로 데이터와 명령어 이다.  

컴퓨터가 이해하는 숫자, 문자, 이미지, 도영상과 같은 정적인 정보를 가리켜  
‘데이터’ 라고 한다.  

컴퓨터를 실질적으로 장동시키는 데 더 중요한 정보는 명령어이다.  

명령어는 컴퓨터를 작동시키는 정보이고,  
데이터는 명령어를 위해 존재하는 재료이다.

---

### <컴퓨터의 4가지 핵심 부품>

아두이노, 라즈베리파이, 스마트폰, 노트북, 데스크톱, 서버컴퓨터 등  
세상에는 다양한 컴퓨터가 있다.  

하지만 외관과 용도를 막론하고  
컴퓨터를 이루는 핵심 부품은 크게 다르지 않다.  

컴퓨터의 핵심 부품은 다음과 같다.

- 중앙처리장치(CPU)
- 주기억장치(메모리)
- 보조기억장치
- 입출력장치

---

### 1) 메모리

컴퓨터가 이해하는 정보는 명령어와 데이터라고 했다.  

메모리는 현재 실행되는 프로그램의  
명령어와 데이터를 저장하는 부품이다.  

프로그램이 실행되려면 반드시 메모리에 저장되어 있어야 한다.  

저장된 명령어와 데이터의 위치는 정돈되어있어야한다. 
메모리에는 저장된 값에 빠르고 효율적으로 접근하기 위해 주소(address) 라는 개념이 사용된다.  

프로그램이 실행되기 위해서는 반드시 메모리에 저장되어 있어야 한다.  
메모리는 현재 실행되는 프로그램의 명령어와 데이터를 저장한다.  
메모리에 저장된 값의 위치는 주소로 알 수 있다.

---

### 2) CPU

CPU는 컴퓨터의 두뇌이다.  
CPU는 메모리에 저장된 명령어를 읽어들이고, 해석하고, 실행하는 부품이다.  
CPU 내부 구성 요소 중 가장 중요한 세 가지는 다음과 같다.

- 산술논리연산장치(ALU)
- 레지스터
- 제어장치

ALU는 쉽게말해 계산기이다. 컴퓨터 내부에서 수행되는 대부분의 계산은 ALU가 도맡아 수행한다.  
레지스터는 CPU 내부의 작은 임시 저장장치이다. 프로그램을 실행하는 데 필요한 값들을 임시로 저장한다.  
CPU안에는 여러 개의 레지스터가 존재하고 각기 다른 이름과 역할을 가지고 있다.  
제어장치는 제어신호라는 전기신호를 내보내고 명령어를 해석하는 장치이다.  

- CPU가 메모리에 저장된 값을 읽고 싶을 땐 메모리를 향해 **메모리읽기** 라는 제어신호를 보낸다.  
- CPU가 메모리에 어떤 값을 저장하고 싶을 땐 메모리를 향해 **메모리쓰기** 하는 제어신호를 보낸다.  

CPU는 메모리에 저장된 값을 읽어들이고, 해석하고, 실행하는 장치다.  
CPU 내부에는 ALU, 레지스터, 제어장치가 있다.  
ALU는 계산하는 장치,  
레지스터는 임시 저장 장치,  
제어장치는 제어 신호를 발생시키고 명령어를 해석하는 장치이다.

---

### 3) 보조기억장치

메모리는 실행되는 프로그램의 명령어와 데이터를 저장한다고 했다.  
하지만 이 메모리는 두가지의 치명적인 약점이 있다.

첫째. 가격이 비싸다.  
둘째. 전원이 꺼지면 저장된 내용을 잃는다.  

실행중인 프로그램들은 메모리에 저장되는데 메모리는 전원이 꺼지면 저장된 내용이 날아간다.  

이에 메모리보다 크기가 크고  전원이 꺼져도 저장된 내용을 잃지 않는  메모리를 보조할 저장장치가 필요하게 되었으며 이 저장장치가 보조기억장치이다.

- 하드디스크
- SSD
- USB메모리
- DVD
- CD-ROM

메모리가 현재 ‘실행되는’ 프로그램을 저장한다면  
보조기억장치는 ‘보관할’ 프로그램을 저장한다.

---

### 4) 입출력장치

입출력장치는 마이크, 스피커, 프린터,  마우스, 키보드처럼  
컴퓨터 외부에 연결되어  컴퓨터 내부와 정보를 교환하는 장치를 의미한다.

---

### 5) 메인보드와 시스템 버스

지금까지 설명한 컴퓨터의 핵심 부품들은  
모두 메인보드라는 판에 연결된다.  
메인보드는 마더보드라고도 부른다.  

메인보드에는 여러 컴퓨터 부품을 부착할 수 있는 슬롯과 연결 단자가 있다.  

메인보드에 연결된 부품들은 서로 정보를 주고받을 수 있는데,  
이는 메인보드 내부에 버스라는 통로가 있기 때문이다.  
컴퓨터의 네가지 핵심 부품을 연결하는 가장 중요한 버스는 시스템 버스이다.  

시스템 버스는 다음으로 구성되어있다.

주소버스 - 주소를 주고받는 통로  
데이터버스 - 명령어와 데이터를 주고받는 통로  
제어버스 - 제어신호를 주고받는 통로  

CPU 구성요소중 하나인 제어장치는 제어버스를 통해 제어 신호를 내보낸다.




--- 
  
# Chapter 2. 데이터

## 02-1 0과 1로 숫차를 표헌하는 방법

#### 정보단위

- 비트 : 0과1을 표현 할 수 있는 **가장작은 정보단위**
- 바이트 : 여덟개의 비트를 묶은 단위
- 킬로바이트 : 바이트 1,000개를 묶은 단위
- 메가바이트 : 킬로바이트 1,000개를 묶은 단위
- 기가바이트 : 메가바이트 1,000개를 묶은 단위
- 테라바이트 : 기가바이트 1,000개를 묶은 단위

#### 워드(word)
워드란 CPU가 한번에 처리할 수 있는 데이터 크기를 의미한다.
만약 CPU가 한 번에 16비트를 처리할 수 있다면 1워드는 16비트가 되고, 
한 번에 32비트를 처리할 수 있다면 1워드는 32비트가 된다.

이렇게 정의된 워드의 절반 크기를 하프워드, 1배 크기를 풀 워드, 2배 크기를 더블워드라고 부른다.
워드 크기가 큰 CPU는 한번에 처리할 수있는 데이터가 많다.
인텔의 x86CPU는 32비트워드CPU
x64 CPU는 64비트 워드 CPU이다. 

--- 
### 2) 이진법
이진법은 1을 넘어가는 시점에 자리 올림을 하여 0과 1만으로 모든 수를 표현하는 방법이다.
- 수학적표기 : 1000(2)
- 코드상의 표기(0b) : 0b1000

--- 
#### 이진수의 음수 표현
0과 1만으로 음수를 표현하는 방법 중 가장 널리 사용되는 방법은 2의 보수를 구해 그 값을 음수로 간주하는 방법이다.  
모든 이진수의 0과 1을 뒤집은 수를 1의 보수라고 하며, 거기에 1을 더한 값을 2의 보수라고 한다.  
- 이진수 : 11
- 1의 보수 : 00
- 2의 보수 : 01 -> 이진수 11의 마이너스값
컴퓨터 내부에서는 어떤 수를 다룰 때 이 수가 양수인지 음수인지를 구분하기 위해 플래그(flag)를 사용한다. 

2의 보수를 취하는 방식은 완벽하지는 않다.
0이나 2^ 형태의 보수를 취할경우 원하는 음수값을 얻을 수 없다.
- 0000 -> 1111 -> 10000
- 1000(2^3) -> 0111 -> 1000

--- 
### 3) 십육진법
이진법은 0과 1만으로 모든 숫자를 표현하다 보니 숫자의 길이가 너무 길어진다는 단점이 있다.  
십육진법은 15를 넘어가는 시점에 자리올림하여 모든 수를 표현하는 방법이다.  
- 수학적표기 : 15(16)
- 코드상의표기(0x) : 0x15

십육진법을 사용하는 주뒨 이유중 하나는 이진수를 십육진수로, 십육진수를 이진수로 변환하기 쉽기 때문이다.

#### 십육진수를 이진수로 변환
십육진수 한 글자를 4비트의 이진수로 간주한다. 
- 1A2B -> 0001 1010 0010 1011

#### 이진수를 십육진수로 변환
이진수 숫자를 네 개씩 끊고 끊어준 네 개의 숫자를 하나의 십육진수로 변환한다.
- 111010101 -> D 5 


## 02-2 0과 1로 문자를 표현하는 방법


### 01) 문자 집합과 인코딩
  
* 문자집합  
컴퓨터가 인식하고 표현할 수 있는 문자의 모음  
컴퓨터는 문자집합에 속해 있는 문자를 이해할 수 있고, 속해있지 않은 문자는 이해할 수 없다.   

* 문자인코딩  
문자를 0과 1로 변환해야 비로소 컴퓨터가 이해할 수 았으며, 이러한 변환 과정을 문자 인코딩 이라고 한다.  
인코딩 후 0과 1로 이루어진 결과값이 문자코드가 된다.   

* 문자디코딩  
인코딩의 반대과정
0과 1로 이루어진 문자를 사람이 이해할 수 있는 문자로 변환하는 과정을 문자 디코딩 이라고 한다.   

---
### 02) 아스키코드
아스키코드는 초창기 문자 집합중 하나다.  
아스키 문자 집합에 속한 문자들은 각각 7비트로 표현되는데   
7비트로 표현할 수 있는 정보의 가짓수는 2^7개로 128개의 문자들을 표현할 수 있다.  
  
실제로는 하나의 아스키 문자를 나타내기 위해 8비트를 사용하지만,  
그 중 1비트는 패리티 비트(parity bit)라고 불리는 오류 검출을 위해 사용되는 비트이다.   

- 아스키문자 : 0부터 127까지의 숫자중 하나의 고유한 수에 일대일로 대응된 문자
- 아스키코드 : 아스키 문자에 대응된 고유한 수

아스키 코드를 이진수로 표현함으로써 아스키 문자를 0과 1로 ㅍ표현할 수 있다.  
아스키 문자는 이렇게 아스키 코드로 인코딩된다.  
제어문자도 아스키 코드에 포함되어있다.  
  
문자 인코딩에서 글자에 부여된 고유한 값을 코드 포인트 라고 한다.   

한국을 포함한 영어권 외의 나라들은 자신들의 언어를 0과 1로 표현할 수 있는 고유한 문자집합과 인코딩 방식이 필요하다고 생각했다.  
아런 이유로 등장한 한글 인코딩 방식이 EUC-KR이다.   

---
### 03) EUC-KR
알파벳을 쭉 이어쓰면 단어가 되는 영어와는 달리,  
한글은 각 음절 하나하나가 초성, 중성, 종성의 조합으로 이루어져있다   
그래서 한글 인코딩에는 두 가지 방식, 완성형(한글 완성형 인코딩) 과 조합형(한글 조합형 인코딩)이 존재한다.  

#### 완성형 인코딩
초정, 중성, 종성의 조합으로 이루어진 완성된 하나의 글자에 고유한 코드를 부여하는 인코딩 방식.  
예를 들어 ‘가’ 는 1, ‘나’는 2 이런식으로 인코딩한다.   

#### 조합형 인코딩  
초성을 위한 비트열, 중성을 위한 비트열, 종성을 위한 비트열을 할당하여  
그것들의 조합으로 하나의 글자 코드를 완성하는 인코딩 방식이다.  
초성 중성 종성에 해당하는 코드를 합하여 하나의 글자코드를 만드는 인코딩 방식이다.  

***EUC-KR 은 대표적인 완성형 인코딩 방식*** 이다.    
EUC-KR 인코딩은 초성, 중성, 종성이 모두 결합된 한글 단어에 ***2바이트*** 크기의 코드를 부여한다.  
  
EUC-KR로 인코딩된 한글 한 글자를 표현하려면 16비트가 필요하며, 16진수로 나타낼 수 있다.  

EUC-KR은 모든 한글 조합을 표현할 수 있을 정도로 많은 양은 아니어서,  
EUC-KR 로 인코딩으로 만든 문자 집합에 정의되지 않은 쀍, 뷁 값은 문자는 표현할 수 없다.  

---
### 04) 유니코드와 UTF-8
언어별로 인코딩을 나라마다 해야 한다면 다국어를 지원하는 프로그램을 만들 때  
각 나라 언어의 인코딩을 모두 알아야 하는 번거로움이 있다.  
***모든 언어를 아우르르 문자 집합과 통일된 인코딩 방식을 위해 등장한 것*** 이 ***유니코드 문자*** 집합이다.   

유니코드는 EUC-KR보다 훨씬 다양한 한글을 포함하며  
대부분 나라의 문자, 특수문자, 화살표나 이모티콘까지도 코드로 표현할 수 있다.  

유니코드 문자집합에서는 아스키 코드나 EUC-KR과 같이 각 문자마다 고유한 값이 부여된다.  
***아스키 코드나 EUC-KR은 글자에 부여된 값을 그대로 인코딩 값***으로 삼는다.  
***유니코드는 이 값을 다양한 방법으로 인코딩***한다.  

인코딩 방법에는 크게 **UTF-8, UTF-16, UTF-32***등이 있다.  
***UTF***는 ***Unicode Transformation Format***의 약어로 유니코드를 인코딩하는 방법이다. 

---
#### UTF-8  
UTF-8은 통상 1바이트부터 4바이트까지의 인코딩 결과를 만들어 낸다.  
UTF-8로 인코딩한 ㄱ밧의 결과는 1바이트가 될수도, 2바이트, 3바이트, 4바이트가 될 수도 있다.  
인코딩한 결과가 몇 바이트가 될 지는 유니코드 문자에 부여된 값의 번위에 따라 결정된다.  
- 유니코드 문자에 부여된 값의 범위가 0부터 007F 까지는 1바이트로 표현
- 유니코드 문자에 부여된 값의 범위가 0080 부터 07FF 까지는 2바이트로 표현
- 유니코드 문자에 부여된 값의 범위가 0800부터 FFFF 까지는 3바이트로 표현
- 유니코드 문자에 부여된 값의 범위가 10000 부터 10FFFF 까지는 4바이트로 표현

한글은 글자가 0800 ~ FFFF 사이에 있어 3바이트로 표현하게 된다.  
- 한 -> D55C -> 1101 0101 0101 1100 -> (1110)1101 (10)01001 (10)011100






# Chapter 3. 명령어 

## 03-1 소스코드와 명령어

컴퓨터는 **명령어를 처리하는 기계**이다.
모든 소스코드는 컴퓨터 내부에서 명령어로 변환된다. 

--- 
### 01) 고급언어와 저급언어
  
#### 고급언어 
컴퓨터가 이해하는 언어가 아닌 **사람이 이해하고 장석하기 쉽게 만들어진 언어**이다.  
이렇게 사람을 위한 언어를 **고급언어**라고 한다.  
사람이 읽고 쓰지 편하며, 더 나은 가독성, 변수나 함수같은 편리한 문법을 제공하여 복잡한 프로그램을 구현할 수 있다.  

#### 저급언어
**컴퓨터가 직접 이해하고 실행할 수 있는 언어**  
저급언어는 **명령어**로 이루어져있다.  
고급 언어로 작성된 소스코드가 실행되려면 반드시 저급언어, 즉 명령어로 변환되어야한다.  
저급언어에는 **기계어**와 **에셈블리어**가 있다.  

#### 기계어
0과 1의 명령어 비트로 이루어진 저급언어  
가독성을 위해 십육진수로 표현하기도 한다.  

#### 어셈블리어
기계어는 오로지 컴퓨터만을 위해 만들어진 언어이기 때문에 사람이 읽으면 그 의미를 이해하기 어렵다  
**0과 1로 표현된 기계어를 읽기 편한 형태로 번역한 언어**가 어셈블리어 이다.   
하드웨어와 밀접하게 맞닿아 있는 프로그램을 개발하는 임베디드 개발자, 게임 개발자,  
정보보안 분야 등의 개발자는 아래와 같이 어셈블리어를 많이 이용한다.  
어셈블리어를 읽으면 컴퓨터가 프로그램을 어떤 과정을 실행하는지 근본적인 단계에서부터 하나하나 추적 및 관찰할 수 있다.  


--- 
### 02) 컴파일 언어와 인터프리터 언어
  
고급 언어가 저급 언어로 변환되는 데에는 크게 **컴파일 방식**과 **인터프리트 방식**이 있다.  
컴파일 방식으로 작동하는 프로그래밍 언어를 **컴파일 언어**,  
인터프리트 방식으로 작동하는 프로그래밍 언어를 **인터프리터 언어** 라고 한다.  

(고급언어 )  
컴파일언어    ——— 컴파일 ——-> 저급언어  
인터프리터언어 —- 인터프리트 —-> 저급언어  
  

#### 컴파일 언어
컴파일러에 의해 소스코드 전체가 저급 언어로 변환되어 실행되는 고급 언어  
대표적인 컴파일 언어로는 **C**가 있다.  
컴파일 언어로 작성된 소스 코드는 **코드 전체가 저급 언어로 변환되는 과정**을 거치며, 이 과정을 **컴파일** 이라고 한다.  
컴파일을 수행해 주는 도구를 **컴파일러** 라고 한다.  
컴파일러는 개발자가 작성한 소스코드 전체를 보고 문법적인 오류는 없는지, 실행가능한 코드인지 등을 따지며,  
소스코드 내에 **오류를 하나라도 발견할 경우 컴파일에 실패**한다.  
컴파일러를 통해 저급 언어로 변환된 코드를 **목적코드** 라고 한다.   

#### 인터프리터 언어
인터프리터에 의해 **소스코드가 한 줄씩 실행**되는 고급언어   
**Python**  
소스코드를 한 줄씩 저급 언어로 변환하여 실행해주는 도구를 **인터프리터** 라고 한다.  
소스코드 전체를 저급 언어로 변환하는 시간을 기다릴 필요가 없다.  
**N번째 줄에 문법 오류**가 있더라도 **N-1번째 줄 까지는 올바르게 수행**된다.  

인터프리터 언어는 컴파일 언어보다 느리다.  
컴파일을 통해 나온 목적코드는 저급언어인 반면,  
인터프리터 언어는 소스 코드 마지막에 이를 때 까지 한 줄씩 저급 언어로 해석하며 실행해야 하기 때문이다.   

컴파일 언어와 인터프리터 언어는 명확하게 구분지을 수 없다.  
Phthon 도 컴파일 하지 않는것은 아니며 Java의 경우 저급언어가 되는 과정에서 컴파일과 인터프리트를 동시에 수행한다.   
고급언어가 저급언어로 변환되는 대표적인 방법에는 컴파일 방식과 인터프리트 방식이 있다 정도로만 이해하는것이 좋다.   

--- 
### 03) 목적파일과 실행파일
목적코드가 실행파일이 되기 위해서는 **링킹**이라는 작업을 거쳐야 한다.  
1. 각각의 코드를 **컴파일** 하면 **목적코드**가 생성된다.  
  -> helper.c, main.c => helper.o, main.o (목적코드)  
2. Main.o가 실행되면 해당 코드에 없는 외부 기능들을 연결짓는 작업이 필요하며 이 작업을 **링킹**이라고 한다.  
3. 링킹 작업까지 거치면 하나의 **실행 파일(exe)**이 만들어 진다.   


--- 

## 03-2 명령어의 구조

### 01) 연산 코드와 오퍼랜드

명령어는 무엇을 대상으로, 어떤 작동을 수행하라 는 구조로 되어있다.  
- **연산코드** : 명령어가 수행할 연산  
- **오퍼랜드** : 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치   
연산코드를 연산자, 오퍼랜드를 피연산자 라고도 부르다.   
연산코드가 담기는 영역을 연산코드필드 라고 부르고, 오퍼랜드가 담기는 영역을 오퍼랜드 필드 라고 부른다.   
  
기계어와 어샘블리어 또한 명령어이기 때문에 연산 코드와 오퍼랜드로 구정되어 있다.   

(연산코드) (오퍼랜드)  
push  rap  
mov  Rap, rsp  
pop  rap  
ret   
  

#### 오퍼랜드
  
오퍼랜드 필드에는 **숫자와 문자 등을 나타내는 데이터** 또는 **메모리나 레지스터 주소**가 올 수 있다.  
오퍼랜드 필드에 숫자나 문자와 같이 연산에 사용할 데이터가 직접 명시되기 보다는  
많은 경우 데이터가 저장된 메모리 주소나 레지스터 이름이 담기기 때문에 **주소필드** 라고도 부른다.   
오퍼랜드는 명령어 안에 하나도 없을 수도 있고, 1개 ,2개, 3개등이 있을수가 있다.   
- **0-주소명령어** : 오퍼랜드가 하나도 없는 명령어  
- **1-주소명령어** : 오퍼랜드가 하나인 명령어  
- **2-주소명령어** : 오퍼랜드가 두개인 명령어  
- **3-주소명령어** : 오퍼랜드가 세개인 명령어  


#### 연산 
코드명령어가 수행할 연산을 의미한다.  
가장 기본적인 연산 코드 유형은 크게 네 가지로 나눌 수 있다   
- 데이터 전송  
- 산술/논리 연산  
- 제어 흐름 변경  
- 입출력 제어   

  
명령어의 종류와 생김새는 CPU마다 다르다.   
  
1. 데이터 전송
  - MOVE : 데이터를 옮겨라
  - STORE : 메모리에 저장하라
  - LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와라
  - PUSH : 스택에 데이터를 저장하라
  - POP : 스택의 최상단 데이터를 가져와라 

2. 산술/논리 연산
  - ADD/SUBSTRACT/MULTIPLY/DIVIDE : 덧셈 뺄셈 곱셈 나눗셈을 수행하라
  - INCREMENT/DECREMENT : 오퍼랜드에 1을 더하라 / 빼라
  - AND/OR/NOT : AND OR NOT 연산을 수행하라
  - COMPARE : 두개의 숫자 또는 TRUE/FALSE 값을 비교하라

3. 제어 흐름 변경
  - JUMP : 특정 주소로 실행 순서를 옮겨라
  - CONDITIONAL JUMP : 조건이 부함할 때 특정 주소로 실행 순서를 옮겨라
  - HALT : 프로그램의 실행을 멈춰라
  - CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라 (함수)
  - RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라 (함수)

4. 입출력 제어
  - READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
  - WRITE(OUTPUT) :특정 입출력 장치로 데이터를 써라
  - START IO : 입출력 장치를 시작하라
  - TEST IO : 입출력 장치의 상태를 확인하라 
  

---   
### 02) 주소 지정 방식
오퍼랜드 필드에 메모리나 레지스터 주소를 담는 경우가 많은데 이는 **명령어의 길이** 때문이다.   
하나의 명령어가 16비트로 구성되어있고 그 중 연산 필드가 4비트라면 오퍼랜드 필드의 길이는 12 비트가 된다.   
-> 2주소 명령어의 경우 2^6 가짓수의 데이터 정보밖에 표현할 수 없다.   

오퍼랜드 필드 안에 메모리 주소가 담긴다면 표현할 수 있는 데이터의 크기는  
하나의 메모리 주소에 저장할 수 있는 공간만큼 커진다.  
  
한 주소에 16 비트를 저장할 수 있는 메모리가 있을 때,  
이 메모리 안에 데이터를 저장하고 오퍼랜드 필드 안에 해당 메모리 주소를 명시한다면  
표현할 수 있는 정보의 가짓수가 2^16으로 커진다.  
  
레지스터 이름을 명시한다면 정보의 가짓수는 해당 레지스터가 저장할 수 있는 공간만큼 커진다.   
  
연산의 대상이 되는 데이터가 저장된 위치를 **유효주소** 라고 한다.   
  
오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때  
연산에 사용할 데이터 위치를 찾는 방법을 **주소지정방식** 이라고 한다.  
**유효 주소**를 찾는 방법이다.  


#### 즉시 주소 지정 방식
- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
- 데이터의 크기가 작아지는 단점
- 다른 주소 지정 방식들보다 속도가 빠르다. 

#### 직접 주소 지정 방식
- 오퍼랜드 필드에 **유효주소**를 직접적으로 명시하는 방식
- 즉시 주소 지정 방식보다 표현할 수 있는 데이터 가짓수는 더 커졌지만,  
  **여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수 만큼 줄어든다**.
- 표현할 수 있는 **유효주소에 제한**이 생길 수 있다. 

#### 간접 주소 지정 방식
- **유효 주소의 주소**를 오퍼랜드 필드에 명시한다.
- 표현할 수 있는 유효 주소의 범위가 더 넓어진다.
- **두번의 메모리 접근**이 필요하기 때문에 **일방적으로 느린 방식**이다.
  
#### 레지스터 주소 지정 방식
- 연산에 사용할 **데이터를 저장한 레지스터**를 오퍼랜드 필드에 직접 명시
- 외부에 있는 메모리에 접근하는 것 보다 **CPU 내부에 있는 레지스터에 접근하는 것이 더 빠르다**.
- 집접 주소 지정 방식보다 빠르게 데이터에 접근할 수 있다.
- 표현할 수 있는 **레지스터 크기에 제한**이 생길 수 있다. 
  
#### 레지스터 간접 주소 지정 방식
- 연산에 사용할 **데이터를 메모리에 저장**하고,그 유**효주소를 저장한 레지스터를 오퍼랜드 필드에 명시**하는 방법
- **메모리에 접근하는 횟수가 한 번** 으로 줄어든다.
- 간접 주소 지정 방식보다 빠르다  
  
#### 오퍼랜드 필드에 명시하는 값
1. 즉시 주소 지정 방식 : 연산에 사용할 데이터
2. 직접 주소 지정 방식 : 유효주소 (메모리 주소)
3. 간접 주소 지정 방식 : 유효주소의 주소
4. 레지스터 주소 지정 방식 : 유효주소 (레지스터 이름)
5. 레지스터 간접 주소 지정 방식 : 유효주소를 저장한 레지스터 이름



# Chapter 4. CPU의 작동 원리 

## 04-1 ALU와 제어장치

### CPU
- 메모리에 저장된 명령어를 읽어들이고, 해석하고 실행하는 장치
- ALU : 계산을 담당
- 제어장치 : 명령어를 읽어들이고 해석
- 레지스터 : 작은 임시 저장장치

--- 
### 01) ALU

- ALU는 현산한 결과값과 플러그를 내보낸다.
- ALU가 계산을 하기 위해서는 피연산자와 수행할 연산이 필요하다
- 레지스터를 통해 피연산자를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 제어신호를 받아들인다.
- 레지스터와 제어장치로부터 받아들인 피연산자와 제어신호로 산술연산, 논리연산등을 수행한다. 
  
연산을 수행한 결과는 특정 숫자나 문자가 될 수 있고, 메모리주소가 될 수 있다.   
결괏값은 바로 메모리에 저장되지 않고 레지스터에 저장된다.   
  
CPU가 메모리에 접근하는 속도는 레지스터에 접근하는 속도보다 훨씬 느리다.  
  
연산 결과가 연산 결과를 담을 레지스터보다 큰 상황을 오버플로우 라고 한다.   
  
### 플래그
- ALU는 결괏값 외에 플래그 를 함께 내보낸다.
- 연산 결과에 대한 추가적인 상태정보
- 플래그들은 플래그 레지스터에 저장되며, 
  이 레지스터를 읽으면 연산 결과에 대한 추가적ㅇ니 정보, 참고 정보들을 얻을 수 있다. 

  1. 부호플래그 : 연산한 결과의 부호를 나타낸다. (1.음수 0.양수)
  2. 제로플래그 : 연산한 결과가 0인지 여부를 나타낸다
  3. 캐리플래그 : 연산 결과 올림수나 빌림수가 발생했는지를 나타낸다.
  4. 오버플로우 플래그 : 오버플로우가 발생했는지를 나타낸다.
  5. 인터럽트 플래그 : 인터럽트가 가능한지를 나타낸다.
  6. 슈퍼바이저 플래그 : 커널 모드로 실행주인지, 사용자 모드로 실행중인지를 나타낸다. 

--- 
### 02) 제어장치

* 제어장치
  - 제어장치는 신호를 내보내고, 명령어를 해석하는 부품이다.

* 제어신호
  - 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호
    
(1) 제어장치는 클럭 신호를 받아들인다.  
- 클럭 : 컴퓨터의 모든 부품들을 움직일 수 있게 하는 시간단위
- 컴퓨터의 모든 부품이 클럭 신호에 맞추어 작동하며, 클럭이라는 박자에 맞춰 작동할 뿐 한 박자마다 작동하는 것은 아니다.
  
(2) 제어장치는 ‘해석해야 할 명령어’를 받아들인다.
- CPU가 해석해야할 명령어는 명령어 레지스터 라는 특별한 레지스터에 저장된다.
- 명령어 레지스터로부터 명령어를 받아들이고 해석한 뒤 제어신호를 발생시켜 컴퓨터 부품들에 수행해야 할 내용을 알려준다. 
  
(3) 제어장치는 플래그 레지스터 속 플래그 값을 받아들인다. 
- 플래그 값을 받아들이고 이를 참고하여 제어 신호를 발생시킨다. 
  
(4) 시스템 버스, 그중에서 제어 버스로 전달된 제어 신호를 받아들인다.
- 제어장치는 제어버스를 통해 외부로부터 전달된 제어 신호를 받아들인다.
- CPU 외부에 전달하는 제어신호와 내부에 전달하는 제어신호가 있다.
- 외부에 전달하는 제어신호는 메모리에 전달하는 제어신호와 입출력 장치에 전달하는 제어신호가 있다.
- 외부신호
  1. 메모리에 저장된 값을 읽거나 메모리에 새로운 값을 쓰고 싶다면 메모리로 제어신호를 보낸다.
  2. 입출력장치의 값을 읽거나 새로운 값을 쓰고 싶을 때 입출력장치로 제어신호를 보낸다.
- 내부신호
  1. ALU에 전달하는 제어신호와 레지스터에 전달하는 제어신호가 있다.
  2. ALU에는 수행할 연산을 지시하기 위해
  3. 레지스터에는 레지스터간에 데이터를 이동시키거나 레지스터에 저장된 명령어를 해석하기 위해 신호를 내보낸다. 




 04-2 레지스터

프로그램 속 명령어와 데이터는 실행 전 후로 반드지 레지스터에 저장된다.
따라서 레지스터만 잘 관찰해도 프로그램의 자세한 실행 과정을 알 수 있다. 

01) 반드시 알아야 할 레지스터

프로그램 레지스터
명령어 레지스터
메모리 주소 레지스터
메모리 버퍼 레지스터
플래그 레지스터
범용 레지스터
스택 포인터
베이스 레지스터


프로그램 카운터
메모리에서 가져올 명령어의 주소를 저장한다. 
프로그램 카운터를 명령어 포인터 라고도 부른다.

(2) 명령어 레지스터
메모리에서 읽어 들인 명령어를 조정하는 레지스터
제어장치는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어신호를 내보낸다. 

(3) 메모리 주소 레지스터
메모리의 주소를 저장하는 레지스터
CPU가 읽어들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거치게 된다. 

(4) 메모리 버퍼 레지스터
메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터
CPU가 주소 버스로 내보낼 값이 메모리 주소 레지스터에 저장된다면,  데이터 버스로 주고받을 값은 메모리 버퍼 레지스터를 거친다. 
메모리 데이터 레지스터라고도 불린다. 

레지스터들의 동작 흐름
CPU로 실행할 프로그램이 메모리의 1000번지부터 1500번지까지 있다. 1000번지에는 1101(2)가 저장되어 있다.
프로그램을 처음부터 실행하기 위해 프로그램 카운터에 1000(메모리에서 가져올 명령어의 주소)이 저장된다.  
주소 1000을 읽어오기 위해 주소버스로 1000을 보내야 하며, 이를 위해 메모리 주소 레지스터에 1000이 저장된다. 
메모리 읽기 제어신호화 메모리 주소 레지스터 값이 각각 제어버스와 주소버스를 통해 메모리로 보내진다
메모리 주소 1000에 저장된 값은 데이터 버스를 통해 메모리 버퍼 레지스터에 전달되며, 프로그램 카운터는 증가되어 다음 명령어를 읽을 준비를 한다. 
메모리 버퍼 레지스터에 저장된 값을 명령어 레지스터로 이동된다. 
제어장치는 명령어 레지스터의 명령어를 해석하고 제어신호를 발생시킨다. 

프로그램 카운터는 지속정으로 증가하며 계속해서 다음 명령어를 읽어 들일 준비를 한다. 
CPU가 메모리속 프로그램을 순차적으로 읽어들이고 실행할 수 있는 이유는 CPU속 프로그램 카운터가 꾸준히 증가하기 때문이다. 

(5) 범용 레지스터
다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터
범용 레지스터는 데이터와 주소를 모두 저장할 수 있다. 

(7)플래그 레지스터
연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터


02) 특정 레지스터를 이용한 주소 지정 방식 1 : 스택 주소 지정 방식

스택 주소 지정 방식 
스택과 스택 포인터를 이용한 주소 지정 방식이다. 
스택 포인터가 사용되며 스택 포인터는 스택의 꼭대기를 가르키는 레지스터이다.  
스택 포인터는 스택에 마지막으로 저장한 값의 위치를 저장한다. 
스택 포인터는 스택의 어디까지 데이터가 채워져 있는지에 대한 표시이다.

스택
스택은 메모리 안에 있다.
메모리 안에 스택처럼 사용할 영역이 정해져 있으며 이를 스택영역 이라고 한다. 


03) 특정 레지스터를 이용한 주소 지정 방식 2 : 변위 주소 지정 방식

변위 주소 지정 방식
명령어는 연산코드와 오퍼랜드로 이루어져 있다. 
오퍼랜드 필드에는 메모리의 주소가 담길때도 있다.
변위주소 지정방식은 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식이다. 
변위주소지정방식을 사용하는 명령어는 아래 3개를 담고있다. 
연산코드필드 : 해당 내용을 수행하라
레지스터필드 : 어떤 레지스터의 값과 더할지를 나타내는 필드
오퍼랜드 : 주소를 담고있는 필드
어떤 레지스터를 더하는지에 따라 상대주소지정방식, 베이스 레지스터 주소 지정방식 으로 나뉜다. 

상태 주소 지정 방식
오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식이다.
실행할 명령어의 주소는 (레지스터값 - 오퍼랜드값) 이다
프로그램 카운터에는 읽어 들일 명령어의 주소가 저장되어 있다.
오퍼랜드는 음수가 될수도 양수가 될수도 있다.
CPU는 읽어 들이기로 했던 명령어의 (오퍼랜드값) 을 더한 주소에 접근한다. 

(2) 베이스 레지스터 주소 지정 방식
오퍼랜드와 베이스 레지스터 값을 더하여 유효 주소를 얻는 방식이다. 
베이스 레지스터 : 기준주소 , 오퍼랜드 : 기준 주소로부터 떨어진 거리
베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지를 연산하여 유효 주소를 얻어내는 방식이다. 
  
  

04-3 명령어 사이클과 인터럽트

CPU가 하나의 명령어를 처리하는 흐름을 명령어 사이틀 이라고 한다. 
그리고 그 흐름을 방해하는 것이 인터럽트이다. 

01) 명령어 사이클
명령어들은 일정한 주기가 반복되어 실행되는데 이 주기를 명령어 사이클 이라고 한다. 
가장 첫번째로 명령어를 메모리에서 CPU로 가져와야 하며, 이를 인출 사이클 이라고 한다. 
CPU로 가져온 명령어를 실행하는 단계를 실행 사이클 이라고 한다. 제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어신호를 발생시키는 단계이다
간접 주소 지정 방식의 경우 오퍼랜드 필드에 유효 주소의 주소를 명시하기 때문에, 메모리 접근을 한 번 더 해야한다. 이처럼 명령어를 CPU로 가져왔다고 하더라도 곧바로 실행할 수 없는 경우가 있으며 이 단계를 간접 사이클 이라고 한다. (메모리 한번 더 접근) 

02) 인터럽트
CPU의 작업을 방해하는 신호
동기 인터럽트와 비동기 인터럽트가 있다.

02-1) 동기 인터럽트
CPU에 의해 발생하는 인터럽트. 
CPU가 명령어들을 수행하다가 오류와 깉은 예외적인 상황에 마주쳤을 때 발생
예외 라고 부른다. 

02-2) 비동기 인터럽트
입출력 장치에 의해 발생하는 인터럽트
CPU가 프린터와 같은 입출력 장치에 입출력 작업을 부탁하면 작업을 끝낸 입출력 장치가 CPU에게 완료 알림(인터럽트)를 보낸다. 
키보드 ,마우스와 같은 입출력 장치가 어떠한 입력을 받아들였을 때 이를 처리하기 위해 CPU에 입력 알림(인터럽트)를 보낸다. 
하드웨어 인터럽트라고 부른다. 

03) 하드웨어 인터럽트
CPU는 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 이런 알림과 같은 하드웨어 인터럽트를 사용한다. 
CPU는 프린터로부터 프린트 완료 인터럽트를 받을 때 까지다른 작업을 처리할 수 있다. 
입출력 작업 중에도 CPU로 하여금 효율적으로 명령어를 처리할 수 있게 한다. 

하드웨어 인터럽트 처리 순서
입출력 장치는 CPU에 인터럽트 요청 신호를 보낸다.
CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다. 
CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다. 
인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다. 
CPU는 인터럽트 백터를 참조하여 인터럽트 서비스 루틴을 실행한다. 
인터럽트 서비스 루틴 실행히 끝나면 4에서 백업해 둔 작업을 복구하여 실행을 재개한다. 

인터럽트 요청신호
CPU에게 인터럽트 하기 전 확인차 보내는 요청신호

* 인터럽트 플래그 
인터럽트가 요청을 수용하가 위해서는 플래그 레지스터의 인터럽트 플래그가 활성화 되어 있어야 한다. 
플래그가 ‘가능’ 일 경우 CPU는 인터럽트 요청을 받아들인다. 
모든 하드웨어 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 아니며, 무시할 수 없는 하드웨어 인터럽트가 있다. (정전, 하드웨어 고장)

인터럽트 서비스 루틴
CPU가 인터럽트 요청을 받아들이면 인터럽트 서비스 루틴이라는 프로그램을 실행한다. 
인터럽트를 처리하기 위한 프로그램이다. 

인터럽트 핸들러
어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램 

인터럽트가 발생되는 경우 루틴
정상적으로 작업수행
인터럽트 발생
인터럽트 서비스 루틴으로 점프
인터럽트 서비스 루틴 실행
기존 작업으로 점프
기존 작업 수행 재개

인터럽트 벡터
인터럽트 서비스 루틴을 식별하기 위한 정보
인터럽트 벡터를 알면 인터럽트 서비스 루틴의 시작 주소를알 수 있다.
CPU는 인터럽트 벡터를 통해 특정 인터럽트 서비스 루틴을 처음부터 실행할 수 있다. 
CPU는 하드웨어 인터럽트 요청을 보낸 대상으로부터 데이터 버스를 통해 인터럽트 벡터를 전달받는다. 

CPU가 인터럽트를 처리한다는 말은, 인터럽트 서비스 루틴을 실행하고 본래 수행하던 작업으로 돌아온다는 말이며, CPU가 인터럽트 서비스 루틴을 실행하기 위해 시작 주소를 알아야 하는데 이는 인터럽트 벡터를 통해 알 수 있다. 

인터럽트 서비스 루틴 실행 전 지금까지의 작업 내역들은 어딘가에 백업되어야 한다.
CPU는 현재 프로그램을 재개하기 위한 모든 내용을 스택에 백업한다. 
인터럽트 서비스 루틴을 모두 실행하면 스택에 저장해 둔 값을 다시 불러온 뒤 이전까지 수행하던 작업을 재개한다. 

명령어 사이클은
인출, 실행, 간접, 인터럽트 로 구성된다. 


04) 예외의 종류

(1) 예외
예외의 종류에는 폴트, 트랩, 중단, 소프트웨어 인터럽트가 있다.
예외가 발생하면 CPU는 하던 일을 중단하고 해당 예외를 처리한다.
CPU는 예외를 처리한 후 다시 돌아와 본래 하던 작업 실행을 재개한다.

(2) 폴트
예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개한다. 

(2) 트랩
예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개한다. 
주로 디버깅에 사용된다. 

(3) 중단
CPU가 실행 중인 프로그램을 강제로 중단시킬 수 밖에 없는 심각한 오류를 발견하였을 때 발생한다. 

(4) 소프트웨어 인터럽트
- 시스템 호출이 발생했을 때 나타난다. 

